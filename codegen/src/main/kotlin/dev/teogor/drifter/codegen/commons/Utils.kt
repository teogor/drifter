/*
 * Copyright 2024 teogor (Teodor Grigor)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.teogor.drifter.codegen.commons

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.ParameterizedTypeName
import com.squareup.kotlinpoet.TypeName
import dev.teogor.drifter.codegen.facades.CodeOutputStreamMaker
import dev.teogor.drifter.codegen.facades.writeTo
import java.util.Locale

private val keywords: Set<String> = setOf(
  "in",
  "is",
)

fun String.sanitizePackageName(): String {
  return split(".")
    .joinToString(".") { if (keywords.contains(it)) "`$it`" else it }
}

private val humps = "(?<=.)(?=\\p{Upper})".toRegex()

fun String.toSnakeCase() = replace(humps, "_").uppercase(Locale.US)

fun String.toTitleCase(reverse: Boolean = false): String {
  val firstChar = first().let {
    if (reverse) {
      it.lowercaseChar()
    } else {
      it.uppercaseChar()
    }
  }
  val rest = substring(1)
  return "$firstChar$rest"
}

inline fun fileBuilder(
  packageName: String,
  fileName: String,
  crossinline block: FileSpec.Builder.() -> Unit,
) = FileSpec.builder(
  packageName = packageName,
  fileName = fileName,
).apply {
  addFileComment(
    """
        This file was automatically generated. Do not modify.
        Auto-generated by Drifter. Developed by Teogor (Teodor Grigor)
    """.trimIndent(),
  )
}.apply(block).build()

fun FileSpec.writeWith(
  codeOutputStreamMaker: CodeOutputStreamMaker,
  error: (FileSpec) -> Unit = {},
) {
  try {
    codeOutputStreamMaker.writeTo(this)
  } catch (e: Exception) {
    error(this)
  }
}

fun findCommonBase(string1: String, string2: String): String {
  val parts1 = string1.split(".")
  val parts2 = string2.split(".")

  val commonParts = mutableListOf<String>()

  for (i in 0 until minOf(parts1.size, parts2.size)) {
    if (parts1[i] == parts2[i]) {
      commonParts.add(parts1[i])
    } else {
      break
    }
  }

  return commonParts.joinToString(".")
}

val TypeName.shortName: String
  get() {
    return when (this) {
      is ClassName -> simpleName
      is ParameterizedTypeName -> {
        val rawType = rawType.shortName
        val typeArguments = typeArguments.joinToString(", ", "<", ">") { it.shortName }
        "$rawType$typeArguments"
      }
      else -> {
        // Handle potential errors or unsupported types
        println("Warning: Unsupported type encountered: $this")
        toString() // Use the full type name as a fallback
      }
    }
  }

val TypeName.safe: TypeName
  get() = copy(nullable = false)
